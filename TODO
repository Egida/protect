DONE

    Switch over to libhydrogen in the SDK

    Verify that I can build hydrogen.c in the kernel module and it links and loads

    Setup a test linux server with 10G NIC with latitude.sh

    Verify that I get reflected UDP packets back from the client backend running on latitude.sh

    Update the write_connect_token and read_connect_token so they work with libhydrogen

    Generate a new keypair with hydrogen, because it's not compatible with sodium keypairs
    
    Setup to unit test again

    Add a unit test for connect token. Lock it in.

    Bring back other unit tests that are not related to client/server.

    Move CMake shit into "build" dir because it's terrible

    Work out required crypto steps for client backend token

    It's simple, it's symmetric encryption, so we just have a private key for the client backend

        #define hydro_secretbox_CONTEXTBYTES 8
        #define hydro_secretbox_HEADERBYTES  (20 + 16)
        #define hydro_secretbox_KEYBYTES     32
 
        void hydro_secretbox_keygen(uint8_t key[hydro_secretbox_KEYBYTES]);

        int hydro_secretbox_encrypt(uint8_t *c, const void *m_, size_t mlen, uint64_t msg_id,
                                    const char    ctx[hydro_secretbox_CONTEXTBYTES],
                                    const uint8_t key[hydro_secretbox_KEYBYTES]);

        int hydro_secretbox_decrypt(void *m_, const uint8_t *c, size_t clen, uint64_t msg_id,
                                    const char    ctx[hydro_secretbox_CONTEXTBYTES],
                                    const uint8_t key[hydro_secretbox_KEYBYTES])

    Need to work out what hydro_secretbox_CONTEXTBYTES and hydro_secretbox_HEADERBYTES are for

        // 1. Generate a secret key
        uint8_t key[hydro_secretbox_KEYBYTES];
        hydro_secretbox_keygen(key);

         // 2. Define message, context, and message ID
        const char *message = "This is a secret message.";
        size_t message_len = strlen(message);
        const char context[hydro_secretbox_CONTEXTBYTES] = "my_app_ctx";
        uint64_t msg_id = 12345; // Optional message identifier

        // 3. Prepare buffer for ciphertext
        // Ciphertext length = HEADERBYTES + message_len
        uint8_t ciphertext[hydro_secretbox_HEADERBYTES + message_len];

        // 4. Encrypt the message
        int encrypt_result = hydro_secretbox_encrypt(
            ciphertext,
            (const void *)message,
            message_len,
            msg_id,
            context,
            key
        );

    But aside from this, it looks like a pretty standard encryption/decryption

    msg_id is optional and we can just omit it

    nonce is automatically generated (random) and is secure. it's included in the header part.

    Define the client backend token including crypto parts

    Implement next_write_client_backend_token

    Implement next_read_client_backend_token

    Unit test client backend token

    Define the client init request and response packets (keep them simple for XDP)

    Should just be:

        [0] (17 byte header) (connect token)
        [1] (17 byte header) (client backend token)

    Extend the client state machine so it has initializing as a state

TODO

    Parse the connect token and extract the data needed to initialize

    -------------

    Implement the client sending the client init request packet to n backends until it receives a response. For any zero client backend address, do nothing.

    -------------

    Implement client backend XDP program verifying client init request packet using hydrogen, and responding with an encrypted client backend token

    -------------

    Verify that we get a client backend init response back on the client

    -------------

    Now transition per-client backend from sending client init packets to sending client backend pings once the client init response is received:

    Client backend ping packet:

        [2] (17 byte header) (client backend token) (uint64 request_id)
        [3] (17 byte header) (uint64 request id)

    -------------

    Generalize everything so it works across big and little endian machines.

    Do it by byte swapping so we don't have to do per-field serialiazation. Keep it simple.

    -------------
