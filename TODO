DONE

    Set direct timeout to 10 seconds. We'll want the accelerated timeout to be much longer (30-60 seconds...)

    Implement a timeout on the direct client.

    Implement simplest possible direct connection -> client index slot on the server.

    Unify functions on the client when client connects, timeouts etc. so everything goes through one place.

    Implement a timeout on the server for direct connections.

    Client sends n disconnect packets to server when quitting direct.

    Server reads disconnect packets and disconnects client clean when it quits.

    SSH back into the linux box

    Implement the server XDP program skeleton

    This program should look at any UDP ports at 1024 and above and pass down to userspace only if they pass the packet filter

    Setup the skeleton for AF_XDP in next_server.cpp #ifdef __linux__

    Added generate packet header function

    Sketch out data structures needed by AF_XDP for building packet header

    Keep an array of the client_address_big_endian and client_port_big_endian so we can pass in to the packet header as-is.

    Stash the server_address_big_endian and server_port_big_endian so we can pass it in to the packet header as-is.

    Look up the server ethernet address and save it to a variable

TODO

    First look up the gateway IP address for the network interface by name:

        ubuntu@latitude:~/protect$ netstat -rn | grep UG
        
        0.0.0.0         45.250.253.242  0.0.0.0         UG        0 0          0 eno1

    Then once we have the IP address for the gateway, we can search lines in "arp -a" and look for:

        ubuntu@latitude:~/protect$ arp -a
        
        ? (45.250.253.242) at 50:87:89:d4:37:2d [ether] on eno1

    This way we should be able to always get the correct gateway ethernet address for outgoing packets.

    ps. We assume that XDP servers will *never* be doing any direct communication within a local network.

    -------------

    ... Study docs on sending packets with AF_XDP ...

    -------------

    Implement send with AF_XDP

    -------------

    Implement receive with AF_XDP

    -------------

    *** Good stopping point here ***

































    -------------

    Implement rate limiting in XDP x requests per-y seconds keyed on IP address

    -------------

    Fix the connect token so we never send the user hash over un-encrypted channels

    This involves doing key exchange and switching over to more advanced crypto primitive

    Add these primitives to proton and then upgrade the code in protect to do the key exchange at the same time as processing the connect token

    -------------

    Implement ip2location in client backend

    -------------

    Implement the client ping near relay design

    -------------

    Implement requesting a route and sending packets across it

    -------------

    Double this route and implement multipath

    -------------
